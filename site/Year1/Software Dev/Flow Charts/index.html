
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.1, mkdocs-material-8.5.7">
    
    
      
        <title>Flow Charts - Lilith Notes</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.20d9efc8.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#e92063">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="pink" data-md-color-accent="purple">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#flow-charts" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Lilith Notes" class="md-header__button md-logo" aria-label="Lilith Notes" data-md-component="logo">
      
  <img src="../../../lilith.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Lilith Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Flow Charts
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/LilithsDemon/lilithnotes.github.io" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    LilithsDemon/Lilith-Notes
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  
    
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link md-tabs__link--active">
        Notes
      </a>
    </li>
  

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../../Assignments/Assignment_Presentation/" class="md-tabs__link">
        Assignments
      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Lilith Notes" class="md-nav__button md-logo" aria-label="Lilith Notes" data-md-component="logo">
      
  <img src="../../../lilith.png" alt="logo">

    </a>
    Lilith Notes
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/LilithsDemon/lilithnotes.github.io" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    LilithsDemon/Lilith-Notes
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          Notes
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Notes" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          Notes
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        Home
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_2" type="checkbox" id="__nav_1_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1_2">
          Database design
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Database design" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_2">
          <span class="md-nav__icon md-icon"></span>
          Database design
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Database%20design/Data/" class="md-nav__link">
        Data integrity
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Database%20design/Normal%20Form/" class="md-nav__link">
        Normal Form
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_3" type="checkbox" id="__nav_1_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1_3">
          Networking
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Networking" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_3">
          <span class="md-nav__icon md-icon"></span>
          Networking
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Networking/CPU/" class="md-nav__link">
        CPU
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Networking/Data%20Transmission/" class="md-nav__link">
        Data Transmission
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Networking/Network%20Addresses/" class="md-nav__link">
        Network addresses
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Networking/Network%20components/" class="md-nav__link">
        Network components
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_4" type="checkbox" id="__nav_1_4" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_1_4">
          Software Dev
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Software Dev" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_4">
          <span class="md-nav__icon md-icon"></span>
          Software Dev
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Data%20Dictionaries/" class="md-nav__link">
        Data Dictionaries
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Flow Charts
      </a>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Pseudocode/" class="md-nav__link">
        Pseudocode
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_5" type="checkbox" id="__nav_1_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1_5">
          Web development
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Web development" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_5">
          <span class="md-nav__icon md-icon"></span>
          Web development
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Web%20development/Accessibility/" class="md-nav__link">
        Accessibility
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Web%20development/Introduction%20to%20PHP/" class="md-nav__link">
        Introduction to PHP
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Web%20development/Languages/" class="md-nav__link">
        Langages to learn for UNI
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Web%20development/UK_s%20Data%20protection%20Act%202018/" class="md-nav__link">
        UK's Data protection Act 2018
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          Assignments
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Assignments" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          Assignments
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Assignments/Assignment_Presentation/" class="md-nav__link">
        Web Dev - Presentation
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  <a href="https://github.com/LilithsDemon/lilithnotes.github.io/edit/master/docs/Year1/Software Dev/Flow Charts.md" title="Edit this page" class="md-content__button md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
  </a>


<h1 id="flow-charts">Flow Charts</h1>
<table>
<thead>
<tr>
<th align="center">Symbol</th>
<th align="center">Name</th>
<th align="center">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img src="https://symbols.getvecta.com/stencil_0/0_start-end.1e16dd8199.png" width="100px"></td>
<td align="center">Start/End</td>
<td align="center">An Oval represents a start or end point</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>st=&gt;start: Start
<a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a>op=&gt;operation: Your Operation
<a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a>cond=&gt;condition: Yes or No?
<a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a>e=&gt;end
<a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a>
<a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a>st-&gt;op-&gt;cond
<a id="__codelineno-0-7" name="__codelineno-0-7" href="#__codelineno-0-7"></a>cond(yes)-&gt;e
<a id="__codelineno-0-8" name="__codelineno-0-8" href="#__codelineno-0-8"></a>cond(no)-&gt;op
</code></pre></div>
<script>
    // flowchart.js, v1.17.1
// Copyright (c)2022 Adriano Raiano (adrai).
// Distributed under MIT license
// http://adrai.github.io/flowchart.js

!function(root, factory) {
    if ("object" == typeof exports && "object" == typeof module) module.exports = factory(require("Raphael")); else if ("function" == typeof define && define.amd) define([ "Raphael" ], factory); else {
        var a = factory("object" == typeof exports ? require("Raphael") : root.Raphael);
        for (var i in a) ("object" == typeof exports ? exports : root)[i] = a[i];
    }
}(this, function(__WEBPACK_EXTERNAL_MODULE_16__) {
    /******/
    return function(modules) {
        /******/
        /******/
        // The require function
        /******/
        function __webpack_require__(moduleId) {
            /******/
            /******/
            // Check if module is in cache
            /******/
            if (installedModules[moduleId]) /******/
            return installedModules[moduleId].exports;
            /******/
            /******/
            // Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/
                exports: {},
                /******/
                id: moduleId,
                /******/
                loaded: !1
            };
            /******/
            /******/
            // Return the exports of the module
            /******/
            /******/
            /******/
            // Execute the module function
            /******/
            /******/
            /******/
            // Flag the module as loaded
            /******/
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.loaded = !0, module.exports;
        }
        // webpackBootstrap
        /******/
        // The module cache
        /******/
        var installedModules = {};
        /******/
        /******/
        // Load entry module and return exports
        /******/
        /******/
        /******/
        /******/
        // expose the modules object (__webpack_modules__)
        /******/
        /******/
        /******/
        // expose the module cache
        /******/
        /******/
        /******/
        // __webpack_public_path__
        /******/
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.p = "", __webpack_require__(0);
    }([ /* 0 */
    /*!******************!*\
  !*** ./index.js ***!
  \******************/
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(/*! ./src/flowchart.shim */ 9);
        var parse = __webpack_require__(/*! ./src/flowchart.parse */ 4);
        __webpack_require__(/*! ./src/jquery-plugin */ 15);
        var FlowChart = {
            parse: parse
        };
        "undefined" != typeof window && (window.flowchart = FlowChart), module.exports = FlowChart;
    }, /* 1 */
    /*!**********************************!*\
  !*** ./src/flowchart.helpers.js ***!
  \**********************************/
    /***/
    function(module, exports) {
        function _defaults(options, defaultOptions) {
            if (!options || "function" == typeof options) return defaultOptions;
            var merged = {};
            for (var attrname in defaultOptions) merged[attrname] = defaultOptions[attrname];
            for (attrname in options) options[attrname] && ("object" == typeof merged[attrname] ? merged[attrname] = _defaults(merged[attrname], options[attrname]) : merged[attrname] = options[attrname]);
            return merged;
        }
        function _inherits(ctor, superCtor) {
            if ("function" == typeof Object.create) // implementation from standard node.js 'util' module
            ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }); else {
                // old school shim for old browsers
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
            }
        }
        // move dependent functions to a container so that
        // they can be overriden easier in no jquery environment (node.js)
        module.exports = {
            defaults: _defaults,
            inherits: _inherits
        };
    }, /* 2 */
    /*!*********************************!*\
  !*** ./src/flowchart.symbol.js ***!
  \*********************************/
    /***/
    function(module, exports, __webpack_require__) {
        function Symbol(chart, options, symbol) {
            this.chart = chart, this.group = this.chart.paper.set(), this.symbol = symbol, this.connectedTo = [], 
            this.symbolType = options.symbolType, this.flowstate = options.flowstate || "future", 
            this.lineStyle = options.lineStyle || {}, this.key = options.key || "", this.leftLines = [], 
            this.rightLines = [], this.topLines = [], this.bottomLines = [], this.params = options.params, 
            this.next_direction = options.next && options.direction_next ? options.direction_next : void 0, 
            this.text = this.chart.paper.text(0, 0, options.text), //Raphael does not support the svg group tag so setting the text node id to the symbol node id plus t
            options.key && (this.text.node.id = options.key + "t"), this.text.node.setAttribute("class", this.getAttr("class") + "t"), 
            this.text.attr({
                "text-anchor": "start",
                x: this.getAttr("text-margin"),
                fill: this.getAttr("font-color"),
                "font-size": this.getAttr("font-size")
            });
            var font = this.getAttr("font"), fontF = this.getAttr("font-family"), fontW = this.getAttr("font-weight");
            font && this.text.attr({
                font: font
            }), fontF && this.text.attr({
                "font-family": fontF
            }), fontW && this.text.attr({
                "font-weight": fontW
            }), options.link && this.text.attr("href", options.link), //ndrqu Add click function with event and options params
            options.function && (this.text.attr({
                cursor: "pointer"
            }), this.text.node.addEventListener("click", function(evt) {
                window[options.function](evt, options);
            }, !1)), options.target && this.text.attr("target", options.target);
            var maxWidth = this.getAttr("maxWidth");
            if (maxWidth) {
                for (var words = options.text.split(" "), tempText = "", i = 0, ii = words.length; i < ii; i++) {
                    var word = words[i];
                    this.text.attr("text", tempText + " " + word), tempText += this.text.getBBox().width > maxWidth ? "\n" + word : " " + word;
                }
                this.text.attr("text", tempText.substring(1));
            }
            if (this.group.push(this.text), symbol) {
                var tmpMargin = this.getAttr("text-margin");
                symbol.attr({
                    fill: this.getAttr("fill"),
                    stroke: this.getAttr("element-color"),
                    "stroke-width": this.getAttr("line-width"),
                    width: this.text.getBBox().width + 2 * tmpMargin,
                    height: this.text.getBBox().height + 2 * tmpMargin
                }), symbol.node.setAttribute("class", this.getAttr("class"));
                var roundness = this.getAttr("roundness");
                isNaN(roundness) || (symbol.node.setAttribute("ry", roundness), symbol.node.setAttribute("rx", roundness)), 
                options.link && symbol.attr("href", options.link), options.target && symbol.attr("target", options.target), 
                //ndrqu Add click function with event and options params
                options.function && (symbol.node.addEventListener("click", function(evt) {
                    window[options.function](evt, options);
                }, !1), symbol.attr({
                    cursor: "pointer"
                })), options.key && (symbol.node.id = options.key), this.group.push(symbol), symbol.insertBefore(this.text), 
                this.text.attr({
                    y: symbol.getBBox().height / 2
                }), this.initialize();
            }
        }
        var drawAPI = __webpack_require__(/*! ./flowchart.functions */ 3), drawLine = drawAPI.drawLine, checkLineIntersection = drawAPI.checkLineIntersection;
        /* Gets the attribute based on Flowstate, Symbol-Name and default, first found wins */
        Symbol.prototype.getAttr = function(attName) {
            if (this.chart) {
                var opt1, opt3 = this.chart.options ? this.chart.options[attName] : void 0, opt2 = this.chart.options.symbols ? this.chart.options.symbols[this.symbolType][attName] : void 0;
                return this.chart.options.flowstate && this.chart.options.flowstate[this.flowstate] && (opt1 = this.chart.options.flowstate[this.flowstate][attName]), 
                opt1 || opt2 || opt3;
            }
        }, Symbol.prototype.initialize = function() {
            this.group.transform("t" + this.getAttr("line-width") + "," + this.getAttr("line-width")), 
            this.width = this.group.getBBox().width, this.height = this.group.getBBox().height;
        }, Symbol.prototype.getCenter = function() {
            return {
                x: this.getX() + this.width / 2,
                y: this.getY() + this.height / 2
            };
        }, Symbol.prototype.getX = function() {
            return this.group.getBBox().x;
        }, Symbol.prototype.getY = function() {
            return this.group.getBBox().y;
        }, Symbol.prototype.shiftX = function(x) {
            this.group.transform("t" + (this.getX() + x) + "," + this.getY());
        }, Symbol.prototype.setX = function(x) {
            this.group.transform("t" + x + "," + this.getY());
        }, Symbol.prototype.shiftY = function(y) {
            this.group.transform("t" + this.getX() + "," + (this.getY() + y));
        }, Symbol.prototype.setY = function(y) {
            this.group.transform("t" + this.getX() + "," + y);
        }, Symbol.prototype.getTop = function() {
            var y = this.getY(), x = this.getX() + this.width / 2;
            return {
                x: x,
                y: y
            };
        }, Symbol.prototype.getBottom = function() {
            var y = this.getY() + this.height, x = this.getX() + this.width / 2;
            return {
                x: x,
                y: y
            };
        }, Symbol.prototype.getLeft = function() {
            var y = this.getY() + this.group.getBBox().height / 2, x = this.getX();
            return {
                x: x,
                y: y
            };
        }, Symbol.prototype.getRight = function() {
            var y = this.getY() + this.group.getBBox().height / 2, x = this.getX() + this.group.getBBox().width;
            return {
                x: x,
                y: y
            };
        }, Symbol.prototype.render = function() {
            if (this.next) {
                var self = this, lineLength = this.getAttr("line-length");
                if ("right" === this.next_direction) {
                    var rightPoint = this.getRight();
                    this.next.isPositioned || (this.next.setY(rightPoint.y - this.next.height / 2), 
                    this.next.shiftX(this.group.getBBox().x + this.width + lineLength), function shift() {
                        for (var symb, hasSymbolUnder = !1, i = 0, len = self.chart.symbols.length; i < len; i++) {
                            symb = self.chart.symbols[i];
                            var diff = Math.abs(symb.getCenter().x - self.next.getCenter().x);
                            if (symb.getCenter().y > self.next.getCenter().y && diff <= self.next.width / 2) {
                                hasSymbolUnder = !0;
                                break;
                            }
                        }
                        if (hasSymbolUnder) {
                            if ("end" === self.next.symbolType) return;
                            self.next.setX(symb.getX() + symb.width + lineLength), shift();
                        }
                    }(), this.next.isPositioned = !0, this.next.render());
                } else if ("left" === this.next_direction) {
                    var leftPoint = this.getLeft();
                    this.next.isPositioned || (this.next.setY(leftPoint.y - this.next.height / 2), this.next.shiftX(-(this.group.getBBox().x + this.width + lineLength)), 
                    function shift() {
                        for (var symb, hasSymbolUnder = !1, i = 0, len = self.chart.symbols.length; i < len; i++) {
                            symb = self.chart.symbols[i];
                            var diff = Math.abs(symb.getCenter().x - self.next.getCenter().x);
                            if (symb.getCenter().y > self.next.getCenter().y && diff <= self.next.width / 2) {
                                hasSymbolUnder = !0;
                                break;
                            }
                        }
                        if (hasSymbolUnder) {
                            if ("end" === self.next.symbolType) return;
                            self.next.setX(symb.getX() + symb.width + lineLength), shift();
                        }
                    }(), this.next.isPositioned = !0, this.next.render());
                } else {
                    var bottomPoint = this.getBottom();
                    this.next.isPositioned || (this.next.shiftY(this.getY() + this.height + lineLength), 
                    this.next.setX(bottomPoint.x - this.next.width / 2), this.next.isPositioned = !0, 
                    this.next.render());
                }
            }
        }, Symbol.prototype.renderLines = function() {
            this.next && (this.next_direction ? this.drawLineTo(this.next, this.getAttr("arrow-text") || "", this.next_direction) : this.drawLineTo(this.next, this.getAttr("arrow-text") || ""));
        }, Symbol.prototype.drawLineTo = function(symbol, text, origin) {
            this.connectedTo.indexOf(symbol) < 0 && this.connectedTo.push(symbol);
            var line, yOffset, x = this.getCenter().x, y = this.getCenter().y, right = this.getRight(), bottom = this.getBottom(), top = this.getTop(), left = this.getLeft(), symbolX = symbol.getCenter().x, symbolY = symbol.getCenter().y, symbolTop = symbol.getTop(), symbolRight = symbol.getRight(), symbolLeft = symbol.getLeft(), isOnSameColumn = x === symbolX, isOnSameLine = y === symbolY, isUnder = y < symbolY, isUpper = y > symbolY || this === symbol, isLeft = x > symbolX, isRight = x < symbolX, maxX = 0, lineLength = this.getAttr("line-length"), lineWith = this.getAttr("line-width");
            if (origin && "bottom" !== origin || !isOnSameColumn || !isUnder) if (origin && "right" !== origin || !isOnSameLine || !isRight) if (origin && "left" !== origin || !isOnSameLine || !isLeft) if (origin && "right" !== origin || !isOnSameColumn || !isUpper) if (origin && "right" !== origin || !isOnSameColumn || !isUnder) if (origin && "bottom" !== origin || !isLeft) if (origin && "bottom" !== origin || !isRight || !isUnder) if (origin && "bottom" !== origin || !isRight) if (origin && "right" === origin && isLeft) yOffset = 10 * Math.max(symbol.topLines.length, this.rightLines.length), 
            line = drawLine(this.chart, right, [ {
                x: right.x + lineLength / 2,
                y: right.y
            }, {
                x: right.x + lineLength / 2,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y
            } ], text), this.rightLines.push(line), symbol.topLines.push(line), this.rightStart = !0, 
            symbol.topEnd = !0, maxX = right.x + lineLength / 2; else if (origin && "right" === origin && isRight) yOffset = 10 * Math.max(symbol.topLines.length, this.rightLines.length), 
            line = drawLine(this.chart, right, [ {
                x: symbolTop.x,
                y: right.y - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y - yOffset
            } ], text), this.rightLines.push(line), symbol.topLines.push(line), this.rightStart = !0, 
            symbol.topEnd = !0, maxX = right.x + lineLength / 2; else if (origin && "bottom" === origin && isOnSameColumn && isUpper) yOffset = 10 * Math.max(symbol.topLines.length, this.bottomLines.length), 
            line = drawLine(this.chart, bottom, [ {
                x: bottom.x,
                y: bottom.y + lineLength / 2 - yOffset
            }, {
                x: right.x + lineLength / 2,
                y: bottom.y + lineLength / 2 - yOffset
            }, {
                x: right.x + lineLength / 2,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y
            } ], text), this.bottomLines.push(line), symbol.topLines.push(line), this.bottomStart = !0, 
            symbol.topEnd = !0, maxX = bottom.x + lineLength / 2; else if ("left" === origin && isOnSameColumn && isUpper) {
                var diffX = left.x - lineLength / 2;
                symbolLeft.x < left.x && (diffX = symbolLeft.x - lineLength / 2), yOffset = 10 * Math.max(symbol.topLines.length, this.leftLines.length), 
                line = drawLine(this.chart, left, [ {
                    x: diffX,
                    y: left.y - yOffset
                }, {
                    x: diffX,
                    y: symbolTop.y - lineLength / 2 - yOffset
                }, {
                    x: symbolTop.x,
                    y: symbolTop.y - lineLength / 2 - yOffset
                }, {
                    x: symbolTop.x,
                    y: symbolTop.y
                } ], text), this.leftLines.push(line), symbol.topLines.push(line), this.leftStart = !0, 
                symbol.topEnd = !0, maxX = left.x;
            } else "left" === origin ? (yOffset = 10 * Math.max(symbol.topLines.length, this.leftLines.length), 
            line = drawLine(this.chart, left, [ {
                x: symbolTop.x + (left.x - symbolTop.x) / 2,
                y: left.y
            }, {
                x: symbolTop.x + (left.x - symbolTop.x) / 2,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y
            } ], text), this.leftLines.push(line), symbol.topLines.push(line), this.leftStart = !0, 
            symbol.topEnd = !0, maxX = left.x) : "top" === origin && (yOffset = 10 * Math.max(symbol.topLines.length, this.topLines.length), 
            line = drawLine(this.chart, top, [ {
                x: top.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y
            } ], text), this.topLines.push(line), symbol.topLines.push(line), this.topStart = !0, 
            symbol.topEnd = !0, maxX = top.x); else yOffset = 10 * Math.max(symbol.topLines.length, this.bottomLines.length), 
            line = drawLine(this.chart, bottom, [ {
                x: bottom.x,
                y: bottom.y + lineLength / 2 - yOffset
            }, {
                x: bottom.x + (bottom.x - symbolTop.x) / 2,
                y: bottom.y + lineLength / 2 - yOffset
            }, {
                x: bottom.x + (bottom.x - symbolTop.x) / 2,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y
            } ], text), this.bottomLines.push(line), symbol.topLines.push(line), this.bottomStart = !0, 
            symbol.topEnd = !0, maxX = bottom.x + (bottom.x - symbolTop.x) / 2; else yOffset = 10 * Math.max(symbol.topLines.length, this.bottomLines.length), 
            line = drawLine(this.chart, bottom, [ {
                x: bottom.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y
            } ], text), this.bottomLines.push(line), symbol.topLines.push(line), this.bottomStart = !0, 
            symbol.topEnd = !0, maxX = bottom.x, symbolTop.x > maxX && (maxX = symbolTop.x); else yOffset = 10 * Math.max(symbol.topLines.length, this.bottomLines.length), 
            line = this.leftEnd && isUpper ? drawLine(this.chart, bottom, [ {
                x: bottom.x,
                y: bottom.y + lineLength / 2 - yOffset
            }, {
                x: bottom.x + (bottom.x - symbolTop.x) / 2,
                y: bottom.y + lineLength / 2 - yOffset
            }, {
                x: bottom.x + (bottom.x - symbolTop.x) / 2,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y
            } ], text) : drawLine(this.chart, bottom, [ {
                x: bottom.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y
            } ], text), this.bottomLines.push(line), symbol.topLines.push(line), this.bottomStart = !0, 
            symbol.topEnd = !0, maxX = bottom.x + (bottom.x - symbolTop.x) / 2; else yOffset = 10 * Math.max(symbol.topLines.length, this.rightLines.length), 
            line = drawLine(this.chart, right, [ {
                x: right.x + lineLength / 2,
                y: right.y - yOffset
            }, {
                x: right.x + lineLength / 2,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y
            } ], text), this.rightLines.push(line), symbol.topLines.push(line), this.rightStart = !0, 
            symbol.topEnd = !0, maxX = right.x + lineLength / 2; else yOffset = 10 * Math.max(symbol.topLines.length, this.rightLines.length), 
            line = drawLine(this.chart, right, [ {
                x: right.x + lineLength / 2,
                y: right.y - yOffset
            }, {
                x: right.x + lineLength / 2,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y - lineLength / 2 - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y
            } ], text), this.rightLines.push(line), symbol.topLines.push(line), this.rightStart = !0, 
            symbol.topEnd = !0, maxX = right.x + lineLength / 2; else 0 === symbol.rightLines.length && 0 === this.leftLines.length ? line = drawLine(this.chart, left, symbolRight, text) : (yOffset = 10 * Math.max(symbol.rightLines.length, this.leftLines.length), 
            line = drawLine(this.chart, right, [ {
                x: right.x,
                y: right.y - yOffset
            }, {
                x: right.x,
                y: symbolRight.y - yOffset
            }, {
                x: symbolRight.x,
                y: symbolRight.y - yOffset
            }, {
                x: symbolRight.x,
                y: symbolRight.y
            } ], text)), this.leftLines.push(line), symbol.rightLines.push(line), this.leftStart = !0, 
            symbol.rightEnd = !0, maxX = symbolRight.x; else 0 === symbol.leftLines.length && 0 === this.rightLines.length ? line = drawLine(this.chart, right, symbolLeft, text) : (yOffset = 10 * Math.max(symbol.leftLines.length, this.rightLines.length), 
            line = drawLine(this.chart, right, [ {
                x: right.x,
                y: right.y - yOffset
            }, {
                x: right.x,
                y: symbolLeft.y - yOffset
            }, {
                x: symbolLeft.x,
                y: symbolLeft.y - yOffset
            }, {
                x: symbolLeft.x,
                y: symbolLeft.y
            } ], text)), this.rightLines.push(line), symbol.leftLines.push(line), this.rightStart = !0, 
            symbol.leftEnd = !0, maxX = symbolLeft.x; else 0 === symbol.topLines.length && 0 === this.bottomLines.length ? line = drawLine(this.chart, bottom, symbolTop, text) : (yOffset = 10 * Math.max(symbol.topLines.length, this.bottomLines.length), 
            line = drawLine(this.chart, bottom, [ {
                x: symbolTop.x,
                y: symbolTop.y - yOffset
            }, {
                x: symbolTop.x,
                y: symbolTop.y
            } ], text)), this.bottomLines.push(line), symbol.topLines.push(line), this.bottomStart = !0, 
            symbol.topEnd = !0, maxX = bottom.x;
            if (//update line style
            this.lineStyle[symbol.key] && line && line.attr(this.lineStyle[symbol.key]), line) {
                for (var l = 0, llen = this.chart.lines.length; l < llen; l++) for (var otherLine = this.chart.lines[l], ePath = otherLine.attr("path"), lPath = line.attr("path"), iP = 0, lenP = ePath.length - 1; iP < lenP; iP++) {
                    var newPath = [];
                    newPath.push([ "M", ePath[iP][1], ePath[iP][2] ]), newPath.push([ "L", ePath[iP + 1][1], ePath[iP + 1][2] ]);
                    for (var line1_from_x = newPath[0][1], line1_from_y = newPath[0][2], line1_to_x = newPath[1][1], line1_to_y = newPath[1][2], lP = 0, lenlP = lPath.length - 1; lP < lenlP; lP++) {
                        var newLinePath = [];
                        newLinePath.push([ "M", lPath[lP][1], lPath[lP][2] ]), newLinePath.push([ "L", lPath[lP + 1][1], lPath[lP + 1][2] ]);
                        var line2_from_x = newLinePath[0][1], line2_from_y = newLinePath[0][2], line2_to_x = newLinePath[1][1], line2_to_y = newLinePath[1][2], res = checkLineIntersection(line1_from_x, line1_from_y, line1_to_x, line1_to_y, line2_from_x, line2_from_y, line2_to_x, line2_to_y);
                        if (res.onLine1 && res.onLine2) {
                            var newSegment;
                            line2_from_y === line2_to_y ? line2_from_x > line2_to_x ? (newSegment = [ "L", res.x + 2 * lineWith, line2_from_y ], 
                            lPath.splice(lP + 1, 0, newSegment), newSegment = [ "C", res.x + 2 * lineWith, line2_from_y, res.x, line2_from_y - 4 * lineWith, res.x - 2 * lineWith, line2_from_y ], 
                            lPath.splice(lP + 2, 0, newSegment), line.attr("path", lPath)) : (newSegment = [ "L", res.x - 2 * lineWith, line2_from_y ], 
                            lPath.splice(lP + 1, 0, newSegment), newSegment = [ "C", res.x - 2 * lineWith, line2_from_y, res.x, line2_from_y - 4 * lineWith, res.x + 2 * lineWith, line2_from_y ], 
                            lPath.splice(lP + 2, 0, newSegment), line.attr("path", lPath)) : line2_from_y > line2_to_y ? (newSegment = [ "L", line2_from_x, res.y + 2 * lineWith ], 
                            lPath.splice(lP + 1, 0, newSegment), newSegment = [ "C", line2_from_x, res.y + 2 * lineWith, line2_from_x + 4 * lineWith, res.y, line2_from_x, res.y - 2 * lineWith ], 
                            lPath.splice(lP + 2, 0, newSegment), line.attr("path", lPath)) : (newSegment = [ "L", line2_from_x, res.y - 2 * lineWith ], 
                            lPath.splice(lP + 1, 0, newSegment), newSegment = [ "C", line2_from_x, res.y - 2 * lineWith, line2_from_x + 4 * lineWith, res.y, line2_from_x, res.y + 2 * lineWith ], 
                            lPath.splice(lP + 2, 0, newSegment), line.attr("path", lPath)), lP += 2;
                        }
                    }
                }
                this.chart.lines.push(line), (void 0 === this.chart.minXFromSymbols || this.chart.minXFromSymbols > left.x) && (this.chart.minXFromSymbols = left.x);
            }
            (!this.chart.maxXFromLine || this.chart.maxXFromLine && maxX > this.chart.maxXFromLine) && (this.chart.maxXFromLine = maxX);
        }, module.exports = Symbol;
    }, /* 3 */
    /*!************************************!*\
  !*** ./src/flowchart.functions.js ***!
  \************************************/
    /***/
    function(module, exports) {
        function drawPath(chart, location, points) {
            var i, len, path = "M{0},{1}";
            for (i = 2, len = 2 * points.length + 2; i < len; i += 2) path += " L{" + i + "},{" + (i + 1) + "}";
            var pathValues = [ location.x, location.y ];
            for (i = 0, len = points.length; i < len; i++) pathValues.push(points[i].x), pathValues.push(points[i].y);
            var symbol = chart.paper.path(path, pathValues);
            symbol.attr("stroke", chart.options["element-color"]), symbol.attr("stroke-width", chart.options["line-width"]);
            var font = chart.options.font, fontF = chart.options["font-family"], fontW = chart.options["font-weight"];
            return font && symbol.attr({
                font: font
            }), fontF && symbol.attr({
                "font-family": fontF
            }), fontW && symbol.attr({
                "font-weight": fontW
            }), symbol;
        }
        function drawLine(chart, from, to, text) {
            var i, len;
            "[object Array]" !== Object.prototype.toString.call(to) && (to = [ to ]);
            var path = "M{0},{1}";
            for (i = 2, len = 2 * to.length + 2; i < len; i += 2) path += " L{" + i + "},{" + (i + 1) + "}";
            var pathValues = [ from.x, from.y ];
            for (i = 0, len = to.length; i < len; i++) pathValues.push(to[i].x), pathValues.push(to[i].y);
            var line = chart.paper.path(path, pathValues);
            line.attr({
                stroke: chart.options["line-color"],
                "stroke-width": chart.options["line-width"],
                "arrow-end": chart.options["arrow-end"]
            });
            var font = chart.options.font, fontF = chart.options["font-family"], fontW = chart.options["font-weight"];
            if (font && line.attr({
                font: font
            }), fontF && line.attr({
                "font-family": fontF
            }), fontW && line.attr({
                "font-weight": fontW
            }), text) {
                var centerText = !1, textPath = chart.paper.text(0, 0, text), textAnchor = "start", isHorizontal = !1, firstTo = to[0];
                from.y === firstTo.y && (isHorizontal = !0);
                var x = 0, y = 0;
                centerText ? (x = from.x > firstTo.x ? from.x - (from.x - firstTo.x) / 2 : firstTo.x - (firstTo.x - from.x) / 2, 
                y = from.y > firstTo.y ? from.y - (from.y - firstTo.y) / 2 : firstTo.y - (firstTo.y - from.y) / 2, 
                isHorizontal ? (x -= textPath.getBBox().width / 2, y -= chart.options["text-margin"]) : (x += chart.options["text-margin"], 
                y -= textPath.getBBox().height / 2)) : (x = from.x, y = from.y, isHorizontal ? (from.x > firstTo.x ? (x -= chart.options["text-margin"] / 2, 
                textAnchor = "end") : x += chart.options["text-margin"] / 2, y -= chart.options["text-margin"]) : (x += chart.options["text-margin"] / 2, 
                y += chart.options["text-margin"], from.y > firstTo.y && (y -= 2 * chart.options["text-margin"]))), 
                textPath.attr({
                    "text-anchor": textAnchor,
                    "font-size": chart.options["font-size"],
                    fill: chart.options["font-color"],
                    x: x,
                    y: y
                }), font && textPath.attr({
                    font: font
                }), fontF && textPath.attr({
                    "font-family": fontF
                }), fontW && textPath.attr({
                    "font-weight": fontW
                });
            }
            return line;
        }
        function checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
            // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
            var denominator, a, b, numerator1, numerator2, result = {
                x: null,
                y: null,
                onLine1: !1,
                onLine2: !1
            };
            // if we cast these lines infinitely in both directions, they intersect here:
            /*
      // it is worth noting that this should be the same as:
      x = line2StartX + (b * (line2EndX - line2StartX));
      y = line2StartX + (b * (line2EndY - line2StartY));
      */
            // if line1 is a segment and line2 is infinite, they intersect if:
            // if line2 is a segment and line1 is infinite, they intersect if:
            return denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY), 
            0 === denominator ? result : (a = line1StartY - line2StartY, b = line1StartX - line2StartX, 
            numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b, numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b, 
            a = numerator1 / denominator, b = numerator2 / denominator, result.x = line1StartX + a * (line1EndX - line1StartX), 
            result.y = line1StartY + a * (line1EndY - line1StartY), a > 0 && a < 1 && (result.onLine1 = !0), 
            b > 0 && b < 1 && (result.onLine2 = !0), result);
        }
        module.exports = {
            drawPath: drawPath,
            drawLine: drawLine,
            checkLineIntersection: checkLineIntersection
        };
    }, /* 4 */
    /*!********************************!*\
  !*** ./src/flowchart.parse.js ***!
  \********************************/
    /***/
    function(module, exports, __webpack_require__) {
        function parse(input) {
            function getStyle(s) {
                var startIndex = s.indexOf("(") + 1, endIndex = s.indexOf(")");
                return startIndex >= 0 && endIndex >= 0 ? s.substring(startIndex, endIndex) : "{}";
            }
            function getSymbValue(s) {
                var startIndex = s.indexOf("(") + 1, endIndex = s.indexOf(")");
                return startIndex >= 0 && endIndex >= 0 ? s.substring(startIndex, endIndex) : "";
            }
            function getSymbol(s) {
                var startIndex = s.indexOf("(") + 1, endIndex = s.indexOf(")");
                return startIndex >= 0 && endIndex >= 0 ? chart.symbols[s.substring(0, startIndex - 1)] : chart.symbols[s];
            }
            function getNextPath(s) {
                var next = "next", startIndex = s.indexOf("(") + 1, endIndex = s.indexOf(")");
                return startIndex >= 0 && endIndex >= 0 && (next = flowSymb.substring(startIndex, endIndex), 
                next.indexOf(",") < 0 && "yes" !== next && "no" !== next && (next = "next, " + next)), 
                next;
            }
            function getAnnotation(s) {
                var startIndex = s.indexOf("(") + 1, endIndex = s.indexOf(")"), tmp = s.substring(startIndex, endIndex);
                tmp.indexOf(",") > 0 && (tmp = tmp.substring(0, tmp.indexOf(",")));
                var tmp_split = tmp.split("@");
                if (tmp_split.length > 1) return startIndex >= 0 && endIndex >= 0 ? tmp_split[1] : "";
            }
            input = input || "", input = input.trim();
            for (var chart = {
                symbols: {},
                start: null,
                drawSVG: function(container, options) {
                    function getDisplaySymbol(s) {
                        if (dispSymbols[s.key]) return dispSymbols[s.key];
                        switch (s.symbolType) {
                          case "start":
                            dispSymbols[s.key] = new Start(diagram, s);
                            break;

                          case "end":
                            dispSymbols[s.key] = new End(diagram, s);
                            break;

                          case "operation":
                            dispSymbols[s.key] = new Operation(diagram, s);
                            break;

                          case "inputoutput":
                            dispSymbols[s.key] = new InputOutput(diagram, s);
                            break;

                          case "subroutine":
                            dispSymbols[s.key] = new Subroutine(diagram, s);
                            break;

                          case "condition":
                            dispSymbols[s.key] = new Condition(diagram, s);
                            break;

                          case "parallel":
                            dispSymbols[s.key] = new Parallel(diagram, s);
                            break;

                          default:
                            return new Error("Wrong symbol type!");
                        }
                        return dispSymbols[s.key];
                    }
                    var self = this;
                    this.diagram && this.diagram.clean();
                    var diagram = new FlowChart(container, options);
                    this.diagram = diagram;
                    var dispSymbols = {};
                    !function constructChart(s, prevDisp, prev) {
                        var dispSymb = getDisplaySymbol(s);
                        return self.start === s ? diagram.startWith(dispSymb) : prevDisp && prev && !prevDisp.pathOk && (prevDisp instanceof Condition ? (prev.yes === s && prevDisp.yes(dispSymb), 
                        prev.no === s && prevDisp.no(dispSymb)) : prevDisp instanceof Parallel ? (prev.path1 === s && prevDisp.path1(dispSymb), 
                        prev.path2 === s && prevDisp.path2(dispSymb), prev.path3 === s && prevDisp.path3(dispSymb)) : prevDisp.then(dispSymb)), 
                        dispSymb.pathOk ? dispSymb : (dispSymb instanceof Condition ? (s.yes && constructChart(s.yes, dispSymb, s), 
                        s.no && constructChart(s.no, dispSymb, s)) : dispSymb instanceof Parallel ? (s.path1 && constructChart(s.path1, dispSymb, s), 
                        s.path2 && constructChart(s.path2, dispSymb, s), s.path3 && constructChart(s.path3, dispSymb, s)) : s.next && constructChart(s.next, dispSymb, s), 
                        dispSymb);
                    }(this.start), diagram.render();
                },
                clean: function() {
                    this.diagram.clean();
                },
                options: function() {
                    return this.diagram.options;
                }
            }, lines = [], prevBreak = 0, i0 = 1, i0len = input.length; i0 < i0len; i0++) if ("\n" === input[i0] && "\\" !== input[i0 - 1]) {
                var line0 = input.substring(prevBreak, i0);
                prevBreak = i0 + 1, lines.push(line0.replace(/\\\n/g, "\n"));
            }
            prevBreak < input.length && lines.push(input.substr(prevBreak));
            for (var l = 1, len = lines.length; l < len; ) {
                var currentLine = lines[l];
                currentLine.indexOf("->") < 0 && currentLine.indexOf("=>") < 0 && currentLine.indexOf("@>") < 0 ? (lines[l - 1] += "\n" + currentLine, 
                lines.splice(l, 1), len--) : l++;
            }
            for (;lines.length > 0; ) {
                var line = lines.splice(0, 1)[0].trim();
                if (line.indexOf("=>") >= 0) {
                    // definition
                    var parts = line.split("=>"), symbol = {
                        key: parts[0].replace(/\(.*\)/, ""),
                        symbolType: parts[1],
                        text: null,
                        link: null,
                        target: null,
                        flowstate: null,
                        function: null,
                        lineStyle: {},
                        params: {}
                    }, params = parts[0].match(/\((.*)\)/);
                    if (params && params.length > 1) for (var entries = params[1].split(","), i = 0; i < entries.length; i++) {
                        var entry = entries[i].split("=");
                        2 == entry.length && (symbol.params[entry[0]] = entry[1]);
                    }
                    var sub;
                    /* adding support for links */
                    if (symbol.symbolType.indexOf(": ") >= 0 && (sub = symbol.symbolType.split(": "), 
                    symbol.symbolType = sub.shift(), symbol.text = sub.join(": ")), symbol.text && symbol.text.indexOf(":$") >= 0 ? (sub = symbol.text.split(":$"), 
                    symbol.text = sub.shift(), symbol.function = sub.join(":$")) : symbol.symbolType.indexOf(":$") >= 0 ? (sub = symbol.symbolType.split(":$"), 
                    symbol.symbolType = sub.shift(), symbol.function = sub.join(":$")) : symbol.text && symbol.text.indexOf(":>") >= 0 ? (sub = symbol.text.split(":>"), 
                    symbol.text = sub.shift(), symbol.link = sub.join(":>")) : symbol.symbolType.indexOf(":>") >= 0 && (sub = symbol.symbolType.split(":>"), 
                    symbol.symbolType = sub.shift(), symbol.link = sub.join(":>")), symbol.symbolType.indexOf("\n") >= 0 && (symbol.symbolType = symbol.symbolType.split("\n")[0]), 
                    symbol.link) {
                        var startIndex = symbol.link.indexOf("[") + 1, endIndex = symbol.link.indexOf("]");
                        startIndex >= 0 && endIndex >= 0 && (symbol.target = symbol.link.substring(startIndex, endIndex), 
                        symbol.link = symbol.link.substring(0, startIndex - 1));
                    }
                    /* end of link support */
                    /* adding support for flowstates */
                    if (symbol.text && symbol.text.indexOf("|") >= 0) {
                        var txtAndState = symbol.text.split("|");
                        symbol.flowstate = txtAndState.pop().trim(), symbol.text = txtAndState.join("|");
                    }
                    /* end of flowstate support */
                    chart.symbols[symbol.key] = symbol;
                } else if (line.indexOf("->") >= 0) {
                    var ann = getAnnotation(line);
                    ann && (line = line.replace("@" + ann, ""));
                    for (var flowSymbols = line.split("->"), iS = 0, lenS = flowSymbols.length; iS < lenS; iS++) {
                        var flowSymb = flowSymbols[iS], symbVal = getSymbValue(flowSymb);
                        "true" !== symbVal && "false" !== symbVal || (// map true or false to yes or no respectively
                        flowSymb = flowSymb.replace("true", "yes"), flowSymb = flowSymb.replace("false", "no"));
                        var next = getNextPath(flowSymb), realSymb = getSymbol(flowSymb), direction = null;
                        if (next.indexOf(",") >= 0) {
                            var condOpt = next.split(",");
                            next = condOpt[0], direction = condOpt[1].trim();
                        }
                        if (ann && ("condition" === realSymb.symbolType ? "yes" === next || "true" === next ? realSymb.yes_annotation = ann : realSymb.no_annotation = ann : "parallel" === realSymb.symbolType && ("path1" === next ? realSymb.path1_annotation = ann : "path2" === next ? realSymb.path2_annotation = ann : "path3" === next && (realSymb.path3_annotation = ann)), 
                        ann = null), chart.start || (chart.start = realSymb), iS + 1 < lenS) {
                            var nextSymb = flowSymbols[iS + 1];
                            realSymb[next] = getSymbol(nextSymb), realSymb["direction_" + next] = direction, 
                            direction = null;
                        }
                    }
                } else if (line.indexOf("@>") >= 0) for (var lineStyleSymbols = line.split("@>"), iSS = 0, lenSS = lineStyleSymbols.length; iSS < lenSS; iSS++) if (iSS + 1 !== lenSS) {
                    var curSymb = getSymbol(lineStyleSymbols[iSS]), nextSymbol = getSymbol(lineStyleSymbols[iSS + 1]);
                    curSymb.lineStyle[nextSymbol.key] = JSON.parse(getStyle(lineStyleSymbols[iSS + 1]));
                }
            }
            return chart;
        }
        var FlowChart = __webpack_require__(/*! ./flowchart.chart */ 7), Start = __webpack_require__(/*! ./flowchart.symbol.start */ 13), End = __webpack_require__(/*! ./flowchart.symbol.end */ 10), Operation = __webpack_require__(/*! ./flowchart.symbol.operation */ 12), InputOutput = __webpack_require__(/*! ./flowchart.symbol.inputoutput */ 11), Subroutine = __webpack_require__(/*! ./flowchart.symbol.subroutine */ 14), Condition = __webpack_require__(/*! ./flowchart.symbol.condition */ 5), Parallel = __webpack_require__(/*! ./flowchart.symbol.parallel */ 6);
        module.exports = parse;
    }, /* 5 */
    /*!*******************************************!*\
  !*** ./src/flowchart.symbol.condition.js ***!
  \*******************************************/
    /***/
    function(module, exports, __webpack_require__) {
        function Condition(chart, options) {
            options = options || {}, Symbol.call(this, chart, options), this.yes_annotation = options.yes_annotation, 
            this.no_annotation = options.no_annotation, this.textMargin = this.getAttr("text-margin"), 
            this.yes_direction = options.direction_yes, this.no_direction = options.direction_no, 
            this.no_direction || "right" !== this.yes_direction ? this.yes_direction || "bottom" !== this.no_direction || (this.yes_direction = "right") : this.no_direction = "bottom", 
            this.yes_direction = this.yes_direction || "bottom", this.no_direction = this.no_direction || "right", 
            this.text.attr({
                x: 2 * this.textMargin
            });
            var width = this.text.getBBox().width + 3 * this.textMargin;
            width += width / 2;
            var height = this.text.getBBox().height + 2 * this.textMargin;
            height += height / 2, height = Math.max(.5 * width, height);
            var startX = width / 4, startY = height / 4;
            this.text.attr({
                x: startX + this.textMargin / 2
            });
            var start = {
                x: startX,
                y: startY
            }, points = [ {
                x: startX - width / 4,
                y: startY + height / 4
            }, {
                x: startX - width / 4 + width / 2,
                y: startY + height / 4 + height / 2
            }, {
                x: startX - width / 4 + width,
                y: startY + height / 4
            }, {
                x: startX - width / 4 + width / 2,
                y: startY + height / 4 - height / 2
            }, {
                x: startX - width / 4,
                y: startY + height / 4
            } ], symbol = drawPath(chart, start, points);
            symbol.attr({
                stroke: this.getAttr("element-color"),
                "stroke-width": this.getAttr("line-width"),
                fill: this.getAttr("fill")
            }), options.link && symbol.attr("href", options.link), options.target && symbol.attr("target", options.target), 
            options.key && (symbol.node.id = options.key), symbol.node.setAttribute("class", this.getAttr("class")), 
            this.text.attr({
                y: symbol.getBBox().height / 2
            }), this.group.push(symbol), symbol.insertBefore(this.text), this.symbol = symbol, 
            this.initialize();
        }
        var Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2), inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits, drawAPI = __webpack_require__(/*! ./flowchart.functions */ 3), drawPath = drawAPI.drawPath;
        inherits(Condition, Symbol), Condition.prototype.render = function() {
            var self = this;
            this.yes_direction && (this[this.yes_direction + "_symbol"] = this.yes_symbol), 
            this.no_direction && (this[this.no_direction + "_symbol"] = this.no_symbol);
            var lineLength = this.getAttr("line-length");
            if (this.bottom_symbol) {
                var bottomPoint = this.getBottom();
                this.bottom_symbol.isPositioned || (this.bottom_symbol.shiftY(this.getY() + this.height + lineLength), 
                this.bottom_symbol.setX(bottomPoint.x - this.bottom_symbol.width / 2), this.bottom_symbol.isPositioned = !0, 
                this.bottom_symbol.render());
            }
            if (this.right_symbol) {
                var rightPoint = this.getRight();
                this.right_symbol.isPositioned || (this.right_symbol.setY(rightPoint.y - this.right_symbol.height / 2), 
                this.right_symbol.shiftX(this.group.getBBox().x + this.width + lineLength), function shift() {
                    for (var symb, hasSymbolUnder = !1, i = 0, len = self.chart.symbols.length; i < len; i++) if (symb = self.chart.symbols[i], 
                    !self.params["align-next"] || "no" !== self.params["align-next"]) {
                        var diff = Math.abs(symb.getCenter().x - self.right_symbol.getCenter().x);
                        if (symb.getCenter().y > self.right_symbol.getCenter().y && diff <= self.right_symbol.width / 2) {
                            hasSymbolUnder = !0;
                            break;
                        }
                    }
                    if (hasSymbolUnder) {
                        if ("end" === self.right_symbol.symbolType) return;
                        self.right_symbol.setX(symb.getX() + symb.width + lineLength), shift();
                    }
                }(), this.right_symbol.isPositioned = !0, this.right_symbol.render());
            }
            if (this.left_symbol) {
                var leftPoint = this.getLeft();
                this.left_symbol.isPositioned || (this.left_symbol.setY(leftPoint.y - this.left_symbol.height / 2), 
                this.left_symbol.shiftX(-(this.group.getBBox().x + this.width + lineLength)), function shift() {
                    for (var symb, hasSymbolUnder = !1, i = 0, len = self.chart.symbols.length; i < len; i++) if (symb = self.chart.symbols[i], 
                    !self.params["align-next"] || "no" !== self.params["align-next"]) {
                        var diff = Math.abs(symb.getCenter().x - self.left_symbol.getCenter().x);
                        if (symb.getCenter().y > self.left_symbol.getCenter().y && diff <= self.left_symbol.width / 2) {
                            hasSymbolUnder = !0;
                            break;
                        }
                    }
                    if (hasSymbolUnder) {
                        if ("end" === self.left_symbol.symbolType) return;
                        self.left_symbol.setX(symb.getX() + symb.width + lineLength), shift();
                    }
                }(), this.left_symbol.isPositioned = !0, this.left_symbol.render());
            }
        }, Condition.prototype.renderLines = function() {
            this.yes_symbol && this.drawLineTo(this.yes_symbol, this.yes_annotation ? this.yes_annotation : this.getAttr("yes-text"), this.yes_direction), 
            this.no_symbol && this.drawLineTo(this.no_symbol, this.no_annotation ? this.no_annotation : this.getAttr("no-text"), this.no_direction);
        }, module.exports = Condition;
    }, /* 6 */
    /*!******************************************!*\
  !*** ./src/flowchart.symbol.parallel.js ***!
  \******************************************/
    /***/
    function(module, exports, __webpack_require__) {
        function Parallel(chart, options) {
            var symbol = chart.paper.rect(0, 0, 0, 0);
            options = options || {}, Symbol.call(this, chart, options, symbol), this.path1_annotation = options.path1_annotation || "", 
            this.path2_annotation = options.path2_annotation || "", this.path3_annotation = options.path3_annotation || "", 
            this.textMargin = this.getAttr("text-margin"), this.path1_direction = "bottom", 
            this.path2_direction = "right", this.path3_direction = "top", this.params = options.params, 
            "path1" === options.direction_next && !options[options.direction_next] && options.next && (options[options.direction_next] = options.next), 
            "path2" === options.direction_next && !options[options.direction_next] && options.next && (options[options.direction_next] = options.next), 
            "path3" === options.direction_next && !options[options.direction_next] && options.next && (options[options.direction_next] = options.next), 
            options.path1 && options.direction_path1 && options.path2 && !options.direction_path2 && options.path3 && !options.direction_path3 ? "right" === options.direction_path1 ? (this.path2_direction = "bottom", 
            this.path1_direction = "right", this.path3_direction = "top") : "top" === options.direction_path1 ? (this.path2_direction = "right", 
            this.path1_direction = "top", this.path3_direction = "bottom") : "left" === options.direction_path1 ? (this.path2_direction = "right", 
            this.path1_direction = "left", this.path3_direction = "bottom") : (this.path2_direction = "right", 
            this.path1_direction = "bottom", this.path3_direction = "top") : options.path1 && !options.direction_path1 && options.path2 && options.direction_path2 && options.path3 && !options.direction_path3 ? "right" === options.direction_path2 ? (this.path1_direction = "bottom", 
            this.path2_direction = "right", this.path3_direction = "top") : "left" === options.direction_path2 ? (this.path1_direction = "bottom", 
            this.path2_direction = "left", this.path3_direction = "right") : (this.path1_direction = "right", 
            this.path2_direction = "bottom", this.path3_direction = "top") : options.path1 && !options.direction_path1 && options.path2 && !options.direction_path2 && options.path3 && options.direction_path3 ? "right" === options.direction_path2 ? (this.path1_direction = "bottom", 
            this.path2_direction = "top", this.path3_direction = "right") : "left" === options.direction_path2 ? (this.path1_direction = "bottom", 
            this.path2_direction = "right", this.path3_direction = "left") : (this.path1_direction = "right", 
            this.path2_direction = "bottom", this.path3_direction = "top") : (this.path1_direction = options.direction_path1, 
            this.path2_direction = options.direction_path2, this.path3_direction = options.direction_path3), 
            this.path1_direction = this.path1_direction || "bottom", this.path2_direction = this.path2_direction || "right", 
            this.path3_direction = this.path3_direction || "top", this.initialize();
        }
        var Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2), inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;
        inherits(Parallel, Symbol), Parallel.prototype.render = function() {
            this.path1_direction && (this[this.path1_direction + "_symbol"] = this.path1_symbol), 
            this.path2_direction && (this[this.path2_direction + "_symbol"] = this.path2_symbol), 
            this.path3_direction && (this[this.path3_direction + "_symbol"] = this.path3_symbol);
            var lineLength = this.getAttr("line-length");
            if (this.bottom_symbol) {
                var bottomPoint = this.getBottom();
                this.bottom_symbol.isPositioned || (this.bottom_symbol.shiftY(this.getY() + this.height + lineLength), 
                this.bottom_symbol.setX(bottomPoint.x - this.bottom_symbol.width / 2), this.bottom_symbol.isPositioned = !0, 
                this.bottom_symbol.render());
            }
            if (this.top_symbol) {
                var topPoint = this.getTop();
                this.top_symbol.isPositioned || (this.top_symbol.shiftY(this.getY() - this.top_symbol.height - lineLength), 
                this.top_symbol.setX(topPoint.x + this.top_symbol.width), this.top_symbol.isPositioned = !0, 
                this.top_symbol.render());
            }
            var self = this;
            if (this.left_symbol) {
                var leftPoint = this.getLeft();
                this.left_symbol.isPositioned || (this.left_symbol.setY(leftPoint.y - this.left_symbol.height / 2), 
                this.left_symbol.shiftX(-(this.group.getBBox().x + this.width + lineLength)), function shift() {
                    for (var symb, hasSymbolUnder = !1, i = 0, len = self.chart.symbols.length; i < len; i++) if (symb = self.chart.symbols[i], 
                    !self.params["align-next"] || "no" !== self.params["align-next"]) {
                        var diff = Math.abs(symb.getCenter().x - self.left_symbol.getCenter().x);
                        if (symb.getCenter().y > self.left_symbol.getCenter().y && diff <= self.left_symbol.width / 2) {
                            hasSymbolUnder = !0;
                            break;
                        }
                    }
                    if (hasSymbolUnder) {
                        if ("end" === self.left_symbol.symbolType) return;
                        self.left_symbol.setX(symb.getX() + symb.width + lineLength), shift();
                    }
                }(), this.left_symbol.isPositioned = !0, this.left_symbol.render());
            }
            if (this.right_symbol) {
                var rightPoint = this.getRight();
                this.right_symbol.isPositioned || (this.right_symbol.setY(rightPoint.y - this.right_symbol.height / 2), 
                this.right_symbol.shiftX(this.group.getBBox().x + this.width + lineLength), function shift() {
                    for (var symb, hasSymbolUnder = !1, i = 0, len = self.chart.symbols.length; i < len; i++) if (symb = self.chart.symbols[i], 
                    !self.params["align-next"] || "no" !== self.params["align-next"]) {
                        var diff = Math.abs(symb.getCenter().x - self.right_symbol.getCenter().x);
                        if (symb.getCenter().y > self.right_symbol.getCenter().y && diff <= self.right_symbol.width / 2) {
                            hasSymbolUnder = !0;
                            break;
                        }
                    }
                    if (hasSymbolUnder) {
                        if ("end" === self.right_symbol.symbolType) return;
                        self.right_symbol.setX(symb.getX() + symb.width + lineLength), shift();
                    }
                }(), this.right_symbol.isPositioned = !0, this.right_symbol.render());
            }
        }, Parallel.prototype.renderLines = function() {
            this.path1_symbol && this.drawLineTo(this.path1_symbol, this.path1_annotation, this.path1_direction), 
            this.path2_symbol && this.drawLineTo(this.path2_symbol, this.path2_annotation, this.path2_direction), 
            this.path3_symbol && this.drawLineTo(this.path3_symbol, this.path3_annotation, this.path3_direction);
        }, module.exports = Parallel;
    }, /* 7 */
    /*!********************************!*\
  !*** ./src/flowchart.chart.js ***!
  \********************************/
    /***/
    function(module, exports, __webpack_require__) {
        function FlowChart(container, options) {
            options = options || {}, this.paper = new Raphael(container), this.options = defaults(options, defaultOptions), 
            this.symbols = [], this.lines = [], this.start = null;
        }
        var Raphael = __webpack_require__(/*! raphael */ 16), defaults = __webpack_require__(/*! ./flowchart.helpers */ 1).defaults, defaultOptions = __webpack_require__(/*! ./flowchart.defaults */ 8), Condition = __webpack_require__(/*! ./flowchart.symbol.condition */ 5), Parallel = __webpack_require__(/*! ./flowchart.symbol.parallel */ 6);
        FlowChart.prototype.handle = function(symbol) {
            this.symbols.indexOf(symbol) <= -1 && this.symbols.push(symbol);
            var flowChart = this;
            return symbol instanceof Condition ? (symbol.yes = function(nextSymbol) {
                return symbol.yes_symbol = nextSymbol, symbol.no_symbol && (symbol.pathOk = !0), 
                flowChart.handle(nextSymbol);
            }, symbol.no = function(nextSymbol) {
                return symbol.no_symbol = nextSymbol, symbol.yes_symbol && (symbol.pathOk = !0), 
                flowChart.handle(nextSymbol);
            }) : symbol instanceof Parallel ? (symbol.path1 = function(nextSymbol) {
                return symbol.path1_symbol = nextSymbol, symbol.path2_symbol && (symbol.pathOk = !0), 
                flowChart.handle(nextSymbol);
            }, symbol.path2 = function(nextSymbol) {
                return symbol.path2_symbol = nextSymbol, symbol.path3_symbol && (symbol.pathOk = !0), 
                flowChart.handle(nextSymbol);
            }, symbol.path3 = function(nextSymbol) {
                return symbol.path3_symbol = nextSymbol, symbol.path1_symbol && (symbol.pathOk = !0), 
                flowChart.handle(nextSymbol);
            }) : symbol.then = function(nextSymbol) {
                return symbol.next = nextSymbol, symbol.pathOk = !0, flowChart.handle(nextSymbol);
            }, symbol;
        }, FlowChart.prototype.startWith = function(symbol) {
            return this.start = symbol, this.handle(symbol);
        }, FlowChart.prototype.render = function() {
            var symbol, line, maxWidth = 0, maxHeight = 0, i = 0, len = 0, maxX = 0, maxY = 0, minX = 0, minY = 0;
            for (i = 0, len = this.symbols.length; i < len; i++) symbol = this.symbols[i], symbol.width > maxWidth && (maxWidth = symbol.width), 
            symbol.height > maxHeight && (maxHeight = symbol.height);
            for (i = 0, len = this.symbols.length; i < len; i++) symbol = this.symbols[i], symbol.shiftX(this.options.x + (maxWidth - symbol.width) / 2 + this.options["line-width"]), 
            symbol.shiftY(this.options.y + (maxHeight - symbol.height) / 2 + this.options["line-width"]);
            // for (i = 0, len = this.symbols.length; i < len; i++) {
            //   symbol = this.symbols[i];
            //   symbol.render();
            // }
            for (this.start.render(), i = 0, len = this.symbols.length; i < len; i++) symbol = this.symbols[i], 
            symbol.renderLines();
            maxX = this.maxXFromLine;
            var x, y;
            for (i = 0, len = this.symbols.length; i < len; i++) {
                symbol = this.symbols[i];
                var leftX = symbol.getX();
                x = leftX + symbol.width, y = symbol.getY() + symbol.height, leftX < minX && (minX = leftX), 
                x > maxX && (maxX = x), y > maxY && (maxY = y);
            }
            for (i = 0, len = this.lines.length; i < len; i++) {
                line = this.lines[i].getBBox(), x = line.x, y = line.y;
                var x2 = line.x2, y2 = line.y2;
                x < minX && (minX = x), y < minY && (minY = y), x2 > maxX && (maxX = x2), y2 > maxY && (maxY = y2);
            }
            var scale = this.options.scale, lineWidth = this.options["line-width"];
            this.minXFromSymbols < minX && (minX = this.minXFromSymbols), minX < 0 && (minX -= lineWidth), 
            minY < 0 && (minY -= lineWidth);
            var width = maxX + lineWidth - minX, height = maxY + lineWidth - minY;
            this.paper.setSize(width * scale, height * scale), this.paper.setViewBox(minX, minY, width, height, !0);
        }, FlowChart.prototype.clean = function() {
            if (this.paper) {
                var paperDom = this.paper.canvas;
                paperDom.parentNode && paperDom.parentNode.removeChild(paperDom);
            }
        }, module.exports = FlowChart;
    }, /* 8 */
    /*!***********************************!*\
  !*** ./src/flowchart.defaults.js ***!
  \***********************************/
    /***/
    function(module, exports) {
        // defaults
        module.exports = {
            x: 0,
            y: 0,
            // 'roundness': 0,
            "line-width": 3,
            "line-length": 50,
            "text-margin": 10,
            "font-size": 14,
            "font-color": "black",
            // 'font': 'normal',
            // 'font-family': 'calibri',
            // 'font-weight': 'normal',
            "line-color": "black",
            "element-color": "black",
            fill: "white",
            "yes-text": "yes",
            "no-text": "no",
            "arrow-end": "block",
            class: "flowchart",
            scale: 1,
            symbols: {
                start: {},
                end: {},
                condition: {},
                inputoutput: {},
                operation: {},
                subroutine: {},
                parallel: {}
            }
        };
    }, /* 9 */
    /*!*******************************!*\
  !*** ./src/flowchart.shim.js ***!
  \*******************************/
    /***/
    function(module, exports) {
        // add indexOf to non ECMA-262 standard compliant browsers
        Array.prototype.indexOf || (Array.prototype.indexOf = function(searchElement) {
            "use strict";
            if (null === this) throw new TypeError();
            var t = Object(this), len = t.length >>> 0;
            if (0 === len) return -1;
            var n = 0;
            if (arguments.length > 0 && (n = Number(arguments[1]), n != n ? // shortcut for verifying if it's NaN
            n = 0 : 0 !== n && n != 1 / 0 && n != -(1 / 0) && (n = (n > 0 || -1) * Math.floor(Math.abs(n)))), 
            n >= len) return -1;
            for (var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0); k < len; k++) if (k in t && t[k] === searchElement) return k;
            return -1;
        }), // add lastIndexOf to non ECMA-262 standard compliant browsers
        Array.prototype.lastIndexOf || (Array.prototype.lastIndexOf = function(searchElement) {
            "use strict";
            if (null === this) throw new TypeError();
            var t = Object(this), len = t.length >>> 0;
            if (0 === len) return -1;
            var n = len;
            arguments.length > 1 && (n = Number(arguments[1]), n != n ? n = 0 : 0 !== n && n != 1 / 0 && n != -(1 / 0) && (n = (n > 0 || -1) * Math.floor(Math.abs(n))));
            for (var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n); k >= 0; k--) if (k in t && t[k] === searchElement) return k;
            return -1;
        }), String.prototype.trim || (String.prototype.trim = function() {
            return this.replace(/^\s+|\s+$/g, "");
        });
    }, /* 10 */
    /*!*************************************!*\
  !*** ./src/flowchart.symbol.end.js ***!
  \*************************************/
    /***/
    function(module, exports, __webpack_require__) {
        function End(chart, options) {
            var symbol = chart.paper.rect(0, 0, 0, 0, 20);
            options = options || {}, options.text = options.text || "End", Symbol.call(this, chart, options, symbol);
        }
        var Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2), inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;
        inherits(End, Symbol), module.exports = End;
    }, /* 11 */
    /*!*********************************************!*\
  !*** ./src/flowchart.symbol.inputoutput.js ***!
  \*********************************************/
    /***/
    function(module, exports, __webpack_require__) {
        function InputOutput(chart, options) {
            options = options || {}, Symbol.call(this, chart, options), this.textMargin = this.getAttr("text-margin"), 
            this.text.attr({
                x: 3 * this.textMargin
            });
            var width = this.text.getBBox().width + 4 * this.textMargin, height = this.text.getBBox().height + 2 * this.textMargin, startX = this.textMargin, startY = height / 2, start = {
                x: startX,
                y: startY
            }, points = [ {
                x: startX - this.textMargin,
                y: height
            }, {
                x: startX - this.textMargin + width,
                y: height
            }, {
                x: startX - this.textMargin + width + 2 * this.textMargin,
                y: 0
            }, {
                x: startX - this.textMargin + 2 * this.textMargin,
                y: 0
            }, {
                x: startX,
                y: startY
            } ], symbol = drawPath(chart, start, points);
            symbol.attr({
                stroke: this.getAttr("element-color"),
                "stroke-width": this.getAttr("line-width"),
                fill: this.getAttr("fill")
            }), options.link && symbol.attr("href", options.link), options.target && symbol.attr("target", options.target), 
            options.key && (symbol.node.id = options.key), symbol.node.setAttribute("class", this.getAttr("class")), 
            this.text.attr({
                y: symbol.getBBox().height / 2
            }), this.group.push(symbol), symbol.insertBefore(this.text), this.symbol = symbol, 
            this.initialize();
        }
        var Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2), inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits, drawAPI = __webpack_require__(/*! ./flowchart.functions */ 3), drawPath = drawAPI.drawPath;
        inherits(InputOutput, Symbol), InputOutput.prototype.getLeft = function() {
            var y = this.getY() + this.group.getBBox().height / 2, x = this.getX() + this.textMargin;
            return {
                x: x,
                y: y
            };
        }, InputOutput.prototype.getRight = function() {
            var y = this.getY() + this.group.getBBox().height / 2, x = this.getX() + this.group.getBBox().width - this.textMargin;
            return {
                x: x,
                y: y
            };
        }, module.exports = InputOutput;
    }, /* 12 */
    /*!*******************************************!*\
  !*** ./src/flowchart.symbol.operation.js ***!
  \*******************************************/
    /***/
    function(module, exports, __webpack_require__) {
        function Operation(chart, options) {
            var symbol = chart.paper.rect(0, 0, 0, 0);
            options = options || {}, Symbol.call(this, chart, options, symbol);
        }
        var Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2), inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;
        inherits(Operation, Symbol), module.exports = Operation;
    }, /* 13 */
    /*!***************************************!*\
  !*** ./src/flowchart.symbol.start.js ***!
  \***************************************/
    /***/
    function(module, exports, __webpack_require__) {
        function Start(chart, options) {
            var symbol = chart.paper.rect(0, 0, 0, 0, 20);
            options = options || {}, options.text = options.text || "Start", Symbol.call(this, chart, options, symbol);
        }
        var Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2), inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;
        inherits(Start, Symbol), module.exports = Start;
    }, /* 14 */
    /*!********************************************!*\
  !*** ./src/flowchart.symbol.subroutine.js ***!
  \********************************************/
    /***/
    function(module, exports, __webpack_require__) {
        function Subroutine(chart, options) {
            var symbol = chart.paper.rect(0, 0, 0, 0);
            options = options || {}, Symbol.call(this, chart, options, symbol), symbol.attr({
                width: this.text.getBBox().width + 4 * this.getAttr("text-margin")
            }), this.text.attr({
                x: 2 * this.getAttr("text-margin")
            });
            var innerWrap = chart.paper.rect(0, 0, 0, 0);
            innerWrap.attr({
                x: this.getAttr("text-margin"),
                stroke: this.getAttr("element-color"),
                "stroke-width": this.getAttr("line-width"),
                width: this.text.getBBox().width + 2 * this.getAttr("text-margin"),
                height: this.text.getBBox().height + 2 * this.getAttr("text-margin"),
                fill: this.getAttr("fill")
            }), options.key && (innerWrap.node.id = options.key + "i");
            var font = this.getAttr("font"), fontF = this.getAttr("font-family"), fontW = this.getAttr("font-weight");
            font && innerWrap.attr({
                font: font
            }), fontF && innerWrap.attr({
                "font-family": fontF
            }), fontW && innerWrap.attr({
                "font-weight": fontW
            }), options.link && innerWrap.attr("href", options.link), options.target && innerWrap.attr("target", options.target), 
            this.group.push(innerWrap), innerWrap.insertBefore(this.text), this.initialize();
        }
        var Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2), inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;
        inherits(Subroutine, Symbol), module.exports = Subroutine;
    }, /* 15 */
    /*!******************************!*\
  !*** ./src/jquery-plugin.js ***!
  \******************************/
    /***/
    function(module, exports, __webpack_require__) {
        if ("undefined" != typeof jQuery) {
            var parse = __webpack_require__(/*! ./flowchart.parse */ 4);
            !function($) {
                function paramFit(needle, haystack) {
                    return needle == haystack || Array.isArray(haystack) && (haystack.includes(needle) || haystack.includes(Number(needle)));
                }
                var methods = {
                    init: function(options) {
                        return this.each(function() {
                            var $this = $(this);
                            this.chart = parse($this.text()), $this.html(""), this.chart.drawSVG(this, options);
                        });
                    },
                    setFlowStateByParam: function(param, paramValue, newFlowState) {
                        return this.each(function() {
                            var chart = this.chart, nextSymbolKeys = [ "next", "yes", "no", "path1", "path2", "path3" ];
                            for (var property in chart.symbols) if (chart.symbols.hasOwnProperty(property)) {
                                var symbol = chart.symbols[property], val = symbol.params[param];
                                if (paramFit(val, paramValue)) {
                                    symbol.flowstate = newFlowState;
                                    for (var nski = 0; nski < nextSymbolKeys.length; nski++) {
                                        var nextSymbolKey = nextSymbolKeys[nski];
                                        symbol[nextSymbolKey] && symbol[nextSymbolKey].params && symbol[nextSymbolKey].params[param] && paramFit(symbol[nextSymbolKey].params[param], paramValue) && (symbol.lineStyle[symbol[nextSymbolKey].key] = {
                                            stroke: chart.options().flowstate[newFlowState].fill
                                        });
                                    }
                                }
                            }
                            chart.clean(), chart.drawSVG(this);
                        });
                    },
                    clearFlowState: function() {
                        return this.each(function() {
                            var chart = this.chart;
                            for (var property in chart.symbols) if (chart.symbols.hasOwnProperty(property)) {
                                var node = chart.symbols[property];
                                node.flowstate = "";
                            }
                            chart.clean(), chart.drawSVG(this);
                        });
                    }
                };
                $.fn.flowChart = function(methodOrOptions) {
                    return methods[methodOrOptions] ? methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1)) : "object" != typeof methodOrOptions && methodOrOptions ? void $.error("Method " + methodOrOptions + " does not exist on jQuery.flowChart") : methods.init.apply(this, arguments);
                };
            }(jQuery);
        }
    }, /* 16 */
    /*!**************************!*\
  !*** external "Raphael" ***!
  \**************************/
    /***/
    function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_16__;
    } ]);
});
//# sourceMappingURL=flowchart.js.map
</script>

  <hr>
<div class="md-source-file">
  <small>
    
      Last update:
      <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">November 15, 2022</span>
      
        <br>
        Created:
        <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">November 15, 2022</span>
      
    
  </small>
</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="Footer" >
      
        
        <a href="../Data%20Dictionaries/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Data Dictionaries" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Data Dictionaries
            </div>
          </div>
        </a>
      
      
        
        <a href="../Pseudocode/" class="md-footer__link md-footer__link--next" aria-label="Next: Pseudocode" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Pseudocode
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2022 Lucy Gardener
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
      
      
    
    <a href="https://github.com/LilithsDemon" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
      
      
    
    <a href="https://www.instagram.com/lucy__gardener" target="_blank" rel="noopener" title="www.instagram.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg>
    </a>
  
    
    
      
      
    
    <a href="https://github.com/LilithsDemon" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M524.531 69.836a1.5 1.5 0 0 0-.764-.7A485.065 485.065 0 0 0 404.081 32.03a1.816 1.816 0 0 0-1.923.91 337.461 337.461 0 0 0-14.9 30.6 447.848 447.848 0 0 0-134.426 0 309.541 309.541 0 0 0-15.135-30.6 1.89 1.89 0 0 0-1.924-.91 483.689 483.689 0 0 0-119.688 37.107 1.712 1.712 0 0 0-.788.676C39.068 183.651 18.186 294.69 28.43 404.354a2.016 2.016 0 0 0 .765 1.375 487.666 487.666 0 0 0 146.825 74.189 1.9 1.9 0 0 0 2.063-.676A348.2 348.2 0 0 0 208.12 430.4a1.86 1.86 0 0 0-1.019-2.588 321.173 321.173 0 0 1-45.868-21.853 1.885 1.885 0 0 1-.185-3.126 251.047 251.047 0 0 0 9.109-7.137 1.819 1.819 0 0 1 1.9-.256c96.229 43.917 200.41 43.917 295.5 0a1.812 1.812 0 0 1 1.924.233 234.533 234.533 0 0 0 9.132 7.16 1.884 1.884 0 0 1-.162 3.126 301.407 301.407 0 0 1-45.89 21.83 1.875 1.875 0 0 0-1 2.611 391.055 391.055 0 0 0 30.014 48.815 1.864 1.864 0 0 0 2.063.7A486.048 486.048 0 0 0 610.7 405.729a1.882 1.882 0 0 0 .765-1.352c12.264-126.783-20.532-236.912-86.934-334.541ZM222.491 337.58c-28.972 0-52.844-26.587-52.844-59.239s23.409-59.241 52.844-59.241c29.665 0 53.306 26.82 52.843 59.239 0 32.654-23.41 59.241-52.843 59.241Zm195.38 0c-28.971 0-52.843-26.587-52.843-59.239s23.409-59.241 52.843-59.241c29.667 0 53.307 26.82 52.844 59.239 0 32.654-23.177 59.241-52.844 59.241Z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.tabs"], "search": "../../../assets/javascripts/workers/search.16e2a7d4.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.8492ddcf.min.js"></script>
      
        <script src="../../../JS/flowchart.js"></script>
      
    
  </body>
</html>